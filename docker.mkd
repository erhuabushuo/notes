## Docker能做什么?

Docker可以解决虚拟机能够解决的问题,同时也能够解决虚拟机由于资源要求过高而无法解决的问题.

* 隔离应用依赖
* 创建应用镜像并进行复制
* 创建容易分发的即启即用的应用
* 允许实例简单、快速地扩展
* 测试应用并随后销毁它们

创建软件程序可移植的轻量容器


## Docker究竟做了什么？

### 镜像和容器

镜像：类似虚拟机的快照，但更**轻**量。在公共镜像拥有大部分你所要的基础镜像，你可以在此镜像上做修改构建自己的镜像，当然你也可以从头构建自己的镜像。

容器：你可以通过镜像创建容器，相当于在快照创建虚拟机，更**轻**量，应用是由容器运行的。

![Alt text](images/pic1.png)

容器和虚拟机相比有个很大的差异，它们被设计用来运行的单进程，Docker设计者极力推崇“一个容易一个进程的方式”。

容器是被设计来运行一个应用，而非一台机器，Docker提供了用于分离应用与数据的工具

### 链接和数据卷

数据卷：让你可以不受容器生命周期影响进行数据持久化，它保存在容器之外，从而允许你不在影响数据的情况下销毁、重建、修改、丢弃容器。使用Docker需要做出最大的思维变化之一就是：容器应该时短暂和一次性的

卷保存在Docker宿主文件系统上，你可以指定存放路径，会存放目录位置。

![Alt text](images/pic2.png)


链接：容器启动时，将被分配一个随机的私有IP,　其他容器就可以使用这个IP地址进行通讯。Docker允许你创建一个新容器时应用其他现存容器，你将获得引用该容器的别名，也即这两个容器链接在一起了。

## Docker镜像的可可移植性

Docker允许你在一个镜像中指定卷和端口。从这个镜像创建的容器继承了这些设置。但是，Docker不允许你在镜像上指定任何不可移植的内容。

## Docker是怎么办到的

cgroups和union文件系统,cgroup容器隔离，union文件系统用于保存镜像

### Cgroups

Linux内核功能。

* 限制Linux进程组的资源占用（内存，CPU）
* 为进程组制作PID、UTS（UNIX Timesharing System）、IPC、网络、用户及装载命名空间

这里关键点命名空间

### Union文件系统

Union文件系统允许通过union装载来达到一个分层的积累变化。

![Alt text](images/pic3.png)


## 快速入门

### 安装

    which wget
    sudo apt-get update $ sudo apt-get install wget
    wget -qO- https://get.docker.com/ | sh
    service docker start
    
### Hello World

    docker run hello-world
    
### 列出你的镜像

    docker images

    # docker images
    REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
    hello-world         latest              af340544ed62        3 weeks ago         960 B
    
### 下载镜像
    
    docker pull ubuntu:latest

公共registry上有你需要的几乎所有东西的镜像：Ubuntu、Fedora、Postgresql、MySQL、Jenkins、Elasticsearch、Redis等等

### 镜像上创建一个容器

    # docker run --rm -ti ubuntu /bin/bash
    
* --rm：告诉Docker一旦运行的进程退出就删除容器。这在进行测试时非常有用，可免除杂乱
* -ti：告诉Docker分配一个伪终端并进入交互模式。这将进入到容器内，对于快速原型开发或尝试很有用，但不要在生产容器中打开这些标志
* ubuntu: 镜像名
* bin/bash：要运行的命令，因为我们以交互模式启动，它将显示一个容器的提示符

在执行run命令时，你可以指定链接，卷，端口，窗口名称等。

### 在后台执行容器

    # docker run -d ubuntu ping 8.8.8.8
    929362f586c7c903e99f05aaaf4bd9126bb9e064e99c7635cfab884f1bdb6df6    

执行后将会随机分配一个ID.

你可以通过如下检测是否运行：

    # docker ps
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
    929362f586c7        ubuntu              "ping 8.8.8.8"      46 seconds ago      Up 44 seconds                           tender_wozniak

我们发现执行时没有指明窗口名称，docker给我们自动分配了个**tender_wozniak**名字。

我们进行看看它在干嘛

    # docker exec -ti tender_wozniak /bin/bash
    # ps -aux | grep ping                                                                                                                                    
    root         1  0.0  0.0   6508   732 ?        Ss   06:15   0:00 ping 8.8.8.8

### 结束后台任务

    # docker kill 929362f586c7

## Linux命名空间

### UTS

Docker核心其实就是通过LXC(LinuX Container)实现类型VM的功能

LXC隔离主要是来自内核的命名空间，其中pid, net, ipc, mnt, uts等命名空间将容器的进程，网络，消息，文件系统和宿主个离开。

LXC就似一个增强版的Chroot。Chroot是将应用隔离到一个虚拟的私有root下

LXC内部依赖Linux内核的３种隔离机制：

1. Chroot
2. Cgroups
3. Namespaces

Linux 3.12内核支持６种Namespace:

1. UTS: hostname
2. IPC: 进程间通信
3. PID: chroot进程树
4. NS: 挂载点，首次登陆Linux
5. NET: 网络访问，包括接口
6. User: 将本地的虚拟user-id映射到真是的user-id

#### 我们第一个container

    #define _GNU_SOURCE
    #include <sys/types.h>
    #include <sys/wait.h>
    #include <stdio.h>
    #include <sched.h>
    #include <signal.h>
    #include <unistd.h>
    
    #define STACK_SIZE (1024 * 1024)
    
    static char child_stack[STACK_SIZE];
    char *const child_args[] = {
      "/bin/bash",
      NULL
    };
    
    int child_main(void *arg) {
      printf(" - World!\n");
      execv(child_args[0], child_args);
      printf("Ooops\n");
      return 1;
    }
    
    int main(int argc, char *argv[])
    {
      printf(" - Hello?\n");
      int child_pid = clone(child_main, child_stack + STACK_SIZE,
                            SIGCHLD, NULL);
      waitpid(child_pid, NULL, 0);
      return 0;
    }



    $ gcc -Wall main.c -o ns
    hewx@hewx:~/下载/books/virualization/examples$ ./ns 
     - Hello?
     - World!
     $ echo "inside container"
     $ exit (Ctrl + D)
     $ echo "outside container"

如果我们在container里修改hostname，是不是很cool

    #define _GNU_SOURCE
    #include <sys/types.h>
    #include <sys/wait.h>
    #include <stdio.h>
    #include <sched.h>
    #include <signal.h>
    #include <unistd.h>
    
    #define STACK_SIZE (1024 * 1024)
    
    static char child_stack[STACK_SIZE];
    char *const child_args[] = {
      "/bin/bash",
      NULL
    };
    
    int child_main(void *arg) {
      printf(" - World!\n");
      sethostname("In Namespace", 12);
      execv(child_args[0], child_args);
      printf("Ooops\n");
      return 1;
    }
    
    int main(int argc, char *argv[])
    {
      printf(" - Hello?\n");
      int child_pid = clone(child_main, child_stack + STACK_SIZE,
                            CLONE_NEWUTS | SIGCHLD, NULL);
      waitpid(child_pid, NULL, 0);
      return 0;
    }

    root@hewx:~/examples# gcc -Wall main.c -o ns
    root@hewx:~/examples# sudo ./ns 
     - Hello?
     - World!
    root@In Namespace:~/examples# 

